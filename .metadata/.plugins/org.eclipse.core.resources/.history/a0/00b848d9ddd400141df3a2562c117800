package ru.kpfu.itis.group11403.sharipova.map;



import java.util.*;

public class DynamicList<T> implements List<T> {

    private int size = 0;//количесвто элементов в списке
    private Object [] elementData;

    public DynamicList(int initialCapacity) {
        if (initialCapacity > 0){
            elementData = new Object[initialCapacity];
        }else if (initialCapacity == 0){
            elementData = new Object[]{};
        }else {
            throw new IllegalArgumentException("неправильно задан размер списка /" + initialCapacity);
        }
    }
    @Override
    /**
     *  добавляет элемент по индексу в список
     * @throws IndexOutOfBoundsException - если не корректно введен индекс
     */
    public void add(int index, T element) {
        if (!checkRangeForAdd(index)){
            ensureCapacity(5);
        }
        Object temp [] = new Object[elementData.length];
        System.arraycopy(elementData, 0, temp, 0, index);
        temp[index] = element;
        System.arraycopy(elementData,index,temp,index+1,elementData.length-index-1);
        elementData = temp;
        if (index > size){
            size += index - size;
        }
        size++;
    }
    public DynamicList() {
        elementData = new Object[]{};
    }

    @Override
    public int size() {
        return size;
    }

    /**
     * увеличивает размер списка на count
     */
    public void ensureCapacity(int count){
       if (isEmpty()){
           elementData = new Object[count];
       }else {
           Object [] temp = new Object[elementData.length+count];
           System.arraycopy(elementData,0,temp,0,size);
           elementData = temp;
       }
    }

    /**
     * приводит список к размеру size
     */
    public void trimToSize(){
        if (size == elementData.length){
            return;
        }
        if(isEmpty()){
            elementData = new Object[]{};
        }
        Object [] temp = new Object[size];
        System.arraycopy(elementData,0,temp,0,size);
        elementData = temp;

    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    /**
     *  возвращает true, если элемент o содержится в списке
     *  иначе возвращает false
     */
    public boolean contains(Object o) {
        return indexOf(o) >= 0;
    }

    @Override
    /**
     * возвращает итератор
     */
    public Iterator<T> iterator() {

        return new Iterator<T>() {
            private int iterator = 0;
            @Override
            public boolean hasNext() {
                return iterator < size;
            }

            @Override
            public T next() {
                if (iterator == size){
                    throw new NoSuchElementException("Нет такого элемента с индексом " + iterator);
                }
                return (T)elementData[iterator++];

            }
        };
    }

    @Override
    /**
     * добавляет элемент в конец списка, если список полон, то увеличиваем размер на 5
     */
    public boolean add(T t) {
       if (isEmpty() || elementData.length < size+1){
           ensureCapacity(5);// увеличиваем размер списка на 5
       }
       elementData[size++] = t;
       return true;
    }

   

    @Override
    /**
     * удаляет первый попавшийся объект в списке
     * если удаление произошло возвращает true
     * иначе false
     */
    public boolean remove(Object o) {
        Object [] temp = new Object[size];
        if (o == null){
            for (int i = 0; i < size; i++) {
                if (elementData[i] == null){
                    remove(i);
                    return true;
                }
            }
        }else {
            for (int i = 0; i < size; i++) {
                if (o.equals(elementData[i])){
                    remove(i);
                    return true;
                }
            }
        }
        return false;
    }

    @Override
    /**
     * удаляет элемен с индексом index
     *  @throws IndexOutOfBoundsException - если не корректно введен индекс
     *  возращает удаленный элемент, если удаление произошло
     */ 
    public T remove(int index) {
        checkRange(index);
        if (index >= size){
            throw new IndexOutOfBoundsException("некорректный индекс для удаления /" + "size : "+ size);
        }
        Object temp [] = new Object[elementData.length];
        System.arraycopy(elementData, 0, temp, 0, index);
        T oldValue = (T) elementData[index];
        System.arraycopy(elementData,index+1,temp,index,elementData.length-index-1);
        elementData = temp;
        size--;
        return oldValue;
    }
    /**
     * проверка на то, что index корректное значение
     */
    private boolean checkRange(int index){
        if (index < 0 || index >= elementData.length){
            throw new IndexOutOfBoundsException("некорректное значение индекса /" + index );
        }
        return true;
    }

    /**
     * проверка на возможность добавить в список элемент
     */
    private boolean checkRangeForAdd(int index){
        if (index < 0 || index >= elementData.length){
            throw new IndexOutOfBoundsException("не корректное значение индекса /" + "index : "+index+", capacity : " + elementData.length);
        }
        return !(isEmpty() || elementData.length < size + 1);
    }

    @Override
    /**
     * возвращает значение true, если в списке есть все элементы коллеции
     * иначе false
     *  @throws NullPointerException если передана null коллекция
     */ 
    public boolean containsAll(Collection<?> c) {
        checkCollection(c);
        if (c.isEmpty()){
            return true;
        }
        Object [] collectionObj = c.toArray();
        for (int i = 0; i < collectionObj.length; i++) {
            if (!contains(collectionObj[i])){
                return false;
            }
        }
        return true;
    }

    @Override
    /**
     *  добавляет в конец списка все элементы коллекции
     *  если добавлен хотя бы один элемент, возращает true
     *  иначе false
     *  @throws NullPointerException если передана null коллекция
     */ 
    public boolean addAll(Collection<? extends T> c) {
        checkCollection(c);
        if (c.isEmpty()){
            return false;
        }
        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityAddAll(numNew);
        System.arraycopy(a, 0, elementData, size, numNew);
        size += numNew;
        return numNew != 0;
    }
    /**
     *  мето, увеличивающий при необходимости размер списка, для добавления туда 
     *  элементов коллекции размером CSize
     */ 
    private void ensureCapacityAddAll(int CSize){
        int newCapacity = size+CSize;
        if (newCapacity > elementData.length){
            ensureCapacity(newCapacity-elementData.length);

        }
    }

    @Override
    /**
     * добавляет в список все элменты колекции, начиная с индекса index
     *  @throws NullPointerException если передана null коллекция
     *  @throws IndexOutOfBoundsException если не корректный индекс
     * возращает true , если элементы коллекции успешно добавились
     * иначе false 
     */ 
    public boolean addAll(int index, Collection<? extends T> c) {
        checkRangeForAdd(index);
        checkCollection(c);
        Object [] collectionObj = c.toArray();
        int collectionSize = collectionObj.length;
        ensureCapacityAddAll(collectionSize);//при необходимости увеличиваем размер списка
        int numMoved = size - index;
        if (numMoved > 0){
            System.arraycopy(elementData, index, elementData, index + collectionSize,numMoved);
        }
        System.arraycopy(collectionObj, 0, elementData, index, collectionSize);
        size += collectionSize;
        return collectionSize != 0;

    }

    @Override
    /**
     * удаляет все элементы списка, которые содержатся в коллекции
     * если из списка был удален элемент, то возращает true
     * иначе false
     *  @throws NullPointerException если передана null коллекция
     */ 
    public boolean removeAll(Collection<?> c) {
        checkCollection(c);
        int startSize = size;
        if (c.isEmpty()){
            return false;
        }
        for (int i = 0; i < size; i++) {
            if (c.contains(elementData[i])){
                remove(i);
                i--;
            }
        }

        return startSize != size;
    }
    /**
     * проверка коллекция на null
     */
    private void checkCollection(Collection<?> c){
        if (c == null){
            throw new NullPointerException("collection is null");
        }
    }
    @Override
    /**
     * отсавляет элементы, которые есть в коллекции
     * если коллекция пуста, то удаляет все элементы списка
     *  @throws NullPointerException если передана null коллекция
     */ 
    public boolean retainAll(Collection<?> c){
        checkCollection(c);
        int startSize = size;
        if (c.isEmpty()){
            elementData = new Object[]{};
            return true;
        }
        for (int i = 0; i < size; i++) {
            if (!c.contains(elementData[i])){
                remove(i);
                i--;
            }
        }
        return startSize != size;
    }


    @Override
    /**
     * очищаем список, все элементы null и размер равен 0
     */
    public void clear() {
        for (int i = 0; i < size; i++) {
            elementData[i] = null;
        }
        size = 0;
    }

    @Override
    /**
     * возращает элемент с идексом index
     *  @throws IndexOutOfBoundsException если индекс некорректный
     */ 
    public T get(int index) {
        checkRange(index);
        if (index >= size){
            throw new IndexOutOfBoundsException("не корректный индекс");
        }
        return (T)elementData[index];
    }

    @Override
    /**
     * заменяет элемент с идексом index на element
     * возращает замененный элемент
     *  @throws IndexOutOfBoundsException если индекс некорректный
     */ 
    public T set(int index, T element) {
       checkRange(index);
        T oldValue = (T)elementData[index];
        elementData[index] = element;
        return oldValue;
    }

    @Override
    /**
     * возращает наименьший из индексов положения элемента o
     * если элемент не найден возвращает -1
     */ 
    public int indexOf(Object o) {
        if (o == null){
            for (int i = 0; i < size; i++) {
                if (elementData[i] == null){
                    return i;
                }
            }
        }else {
            for (int i = 0; i < size; i++) {
                if (o.equals(elementData[i])){
                    return i;
                }
            }
        }
        return -1;
    }

    @Override
    /**
     * возращает наибольший из индексов положения элемента o
     * или наименшьй из индексов положения элемнта o начиная с конца списка
     * если элемент не найден возвращает -1
     */ 
    public int lastIndexOf(Object o) {
        if (o == null) {
            for (int i = size-1; i >= 0; i--)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = size-1; i >= 0; i--)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }

    @Override
    /**
     * возвращает ListIterator для данного списка
     */ 
    public ListIterator<T> listIterator() {
        return listIterator(0);
    }

    @Override
    /**
     * возвращает ListIterator для данного списка
     * курсор установлен на начальную позицию index
     *  @throws IndexOutOfBoundsException если индекс некорректный
     */ 
    public ListIterator<T> listIterator(int index) {

        return new ListIterator<T>() {
            private int cursor = index;
            private int lastRet = index-1;
            @Override
            public boolean hasNext() {
                return cursor < size;
            }

            @Override
            public T next() {
                if (cursor == size){
                    throw new NoSuchElementException("не существует элемента с индексом " + cursor );
                }
                int i = cursor;
                cursor = i+1;
                return (T)elementData[lastRet = i];
            }

            @Override
            public boolean hasPrevious() {
                return cursor != 0;
            }

            @Override
            public T previous() {
                if (cursor < 0 || cursor >= DynamicList.this.elementData.length){
                    throw new NoSuchElementException("не существует элемента с индексом " + (cursor-1));
                }
                int i = cursor-1;
                cursor = i;
                return (T)elementData[lastRet = i];
            }

            @Override
            public int nextIndex() {
                return cursor;
            }

            @Override
            public int previousIndex() {
                return cursor-1;
            }

            @Override
            public void remove() {
                if (lastRet < 0){
                    throw new NoSuchElementException("невозможно удалить не существующего элемента " + lastRet);
                }
                try{
                    DynamicList.this.remove(lastRet);
                    cursor = lastRet;
                    lastRet = index-1;
                }catch (IndexOutOfBoundsException e){
                    throw new IndexOutOfBoundsException("нельзя удалить не существующий элемент " + e);
                }
            }

            @Override
            public void set(T t) {
                if(last < 0){
                    throw new IndexOutOfBoundsException("не существует элемента с индексом " + lastRet);
                }
                try{
                    DynamicList.this.set(lastRet, t);
                }catch (IndexOutOfBoundsException e){
                    throw new IndexOutOfBoundsException("выход за границы списка " + e);
                }

            }

            @Override
            public void add(T t) {
                if (lastRet < 0){
                    throw new NoSuchElementException("невозможно удалить не существующего элемента " + lastRet);
                }
                try {
                    int i = cursor;
                    DynamicList.this.add(i, t);
                    cursor = i + 1;
                    lastRet = index-1;
                } catch (IndexOutOfBoundsException e) {
                    throw new IndexOutOfBoundsException("выход за границы спсика " + (cursor-1));
                }
            };
        };
    }


    @Override
    public List<T> subList(int fromIndex, int toIndex) {
        if (fromIndex > toIndex && checkRange(fromIndex) && checkRange(toIndex)){
            throw new IndexOutOfBoundsException("некорректные индексы " + "formIndex :"
                    + fromIndex + ", toIndex : "+ toIndex);
        }
        List<T> list;
        Object [] obj = Arrays.copyOfRange(elementData,fromIndex,toIndex);
        if (fromIndex == toIndex){
            list = Collections.EMPTY_LIST;
        }else {
            list = Arrays.asList((T)obj);
        }
        return list;
    }


    @Override
    public Object[] toArray() {
        return Arrays.copyOf(elementData, size);
    }

    @Override
    public <T1> T1[] toArray(T1[] a) {
        return null;
    }


    @Override
    public String toString() {
        return Arrays.toString(elementData);
    }
}